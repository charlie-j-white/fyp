C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C  Differentiation of main in forward (tangent) mode:
C   variations   of useful results: j
C   with respect to varying inputs: area_rat
C   RW status of diff variables: j:out area_rat:in
C
      SUBROUTINE MAIN_D(area_rat, area_ratd, j, jd, n)
      IMPLICIT NONE
C
C
C
C
C 
C-----------------------------------------------------------------------
C
      INTEGER, INTENT(IN) :: n
      DOUBLE PRECISION, INTENT(IN) :: area_rat
      DOUBLE PRECISION, INTENT(IN) :: area_ratd
      DOUBLE PRECISION, INTENT(OUT) :: j
      DOUBLE PRECISION, INTENT(OUT) :: jd
C
      INTEGER ii, jj, tmax
      DOUBLE PRECISION mach_inf, pres_rat, dx, dt, cfl
      DOUBLE PRECISION, DIMENSION(0:n+1) :: s, sx, pres, u1, u2, u5
      DOUBLE PRECISION sd(0:n+1), sxd(0:n+1), presd(0:n+1), u1d(0:n+1), 
     +                 u2d(0:n+1), u5d(0:n+1)
      DOUBLE PRECISION, DIMENSION(-1:n+1) :: xpos
      INTEGER ii1
C
C
C
C define primary flow variables
C-----------------------------------------------------------------------
      mach_inf = 0.3d0
      pres_rat = 0.8d0
      cfl = 0.9d0
      tmax = 100000
C
C
C
C allocate sizes for arrays 
C-----------------------------------------------------------------------
C
C      allocate(S(0:N+1))
C      allocate(Sx(0:N+1))
C      allocate(xpos(-1:N+1))
C      allocate(pres(0:N+1))
C      allocate(u1(0:N+1))
C      allocate(u2(0:N+1))
C      allocate(u5(0:N+1))
C
C
C
C create mesh 
C-----------------------------------------------------------------------
C
C             -1   0   1   2  ... N-2 N-1  N  N+1
C
C position         0                       L
C points       x   o   o   o  ...  o   o   o   x 
C cells          H   C   C    ...    C   C   H
C
C                0   1   2    ...   N-1  N  N+1
C
C
      CALL MESHING_D(area_rat, area_ratd, n, s, sd, sx, sxd, dx, xpos)
C
C
C initialise variables 
C-----------------------------------------------------------------------
C
      CALL INITIALISE(n, mach_inf, pres_rat, pres, u1, u2, u5)
      DO ii1=0,n+1
        u1d(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        u2d(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        u5d(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        presd(ii1) = 0.D0
      ENDDO
C
C
C start time stepping
C-----------------------------------------------------------------------
      DO ii=1,tmax
        CALL BOUNDARIES_D(n, mach_inf, pres_rat, pres, presd, u1, u1d, 
     +                    u2, u2d, u5, u5d)
        CALL UPDATE_D(n, mach_inf, pres_rat, pres, presd, u1, u1d, u2, 
     +                u2d, u5, u5d, s, sd, sx, sxd, dt, dx, cfl)
      ENDDO
C
C
C
C calculate cost function
C-----------------------------------------------------------------------
C
      CALL JCOST_D(n, j, jd, pres, presd, dx)
C
C
C
C
C correct variables for area
C-----------------------------------------------------------------------
C      do ii = 0,N+1
C             u1(ii) = u1(ii)/S(ii)
C             u2(ii) = u2(ii)/S(ii)
C             u5(ii) = u5(ii)/S(ii)
C      end do
C
C
C
C
C
C write info to file
C-----------------------------------------------------------------------
      OPEN(100, file='solution.plt') 
      WRITE(100, *) 'VARIABLES = "x" "u1" "u2" "u5" "pres"'
C
      DO ii=1,n
C
        WRITE(100, 101) xpos(ii), 0.5*(u1(ii)+u1(ii+1)), 0.5*(u2(ii)+u2(
     +        ii+1)), 0.5*(u5(ii)+u5(ii+1)), 0.5*(pres(ii)+pres(ii+1))
      ENDDO
C
 101  FORMAT(5f12.8)
      END

C  Differentiation of jcost in forward (tangent) mode:
C   variations   of useful results: j
C   with respect to varying inputs: pres
C
C
C
      SUBROUTINE JCOST_D(n, j, jd, pres, presd, dx)
      IMPLICIT NONE
C
C
C
C
      INTEGER, INTENT(IN) :: n
      DOUBLE PRECISION, INTENT(IN) :: dx
      DOUBLE PRECISION, INTENT(OUT) :: j
      DOUBLE PRECISION, INTENT(OUT) :: jd
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(IN) :: pres
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(IN) :: presd
C
      INTEGER ii
C
C
      j = 0
      jd = 0.D0
C
C
C
C
C
C for the cost function, integrate vertical pressure (direction normal
C to the gross flow direction) on both upper and lower nozzle surfaces
C-----------------------------------------------------------------------
C
      DO ii=1,n
        jd = jd + 2*dx*presd(ii)
        j = j + 2*dx*pres(ii)
      ENDDO
      END

C  Differentiation of update in forward (tangent) mode:
C   variations   of useful results: u1 u2 u5 pres
C   with respect to varying inputs: s u1 u2 u5 sx pres
C
C
C
      SUBROUTINE UPDATE_D(n, mach_inf, pres_rat, pres, presd, u1, u1d, 
     +                    u2, u2d, u5, u5d, s, sd, sx, sxd, dt, dx, cfl)
      IMPLICIT NONE
C
C
C
C
      INTEGER, INTENT(IN) :: n
      DOUBLE PRECISION, INTENT(IN) :: mach_inf, pres_rat, dx, cfl
      DOUBLE PRECISION, INTENT(OUT) :: dt
      DOUBLE PRECISION dtd
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: pres, u1, u2, 
     +                                                   u5
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: presd, u1d, u2d
     +                                                   , u5d
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(IN) :: s, sx
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(IN) :: sd, sxd
C
      INTEGER ii
      DOUBLE PRECISION gam, pinf, pstag, rinf, rstag, ubc, mbc, pbc, rbc
     +                 , tau, cmax, c
      DOUBLE PRECISION taud, cmaxd, cd
      DOUBLE PRECISION, DIMENSION(0:n+1) :: u1b, u2b, u5b, f1, f2, f5, 
     +                                      f1b, f2b, f5b, q1, q2, q5, 
     +                                      q1b, q2b, q5b
      DOUBLE PRECISION u1bd(0:n+1), u2bd(0:n+1), u5bd(0:n+1), f1d(0:n+1)
     +                 , f2d(0:n+1), f5d(0:n+1), f1bd(0:n+1), f2bd(0:n+1
     +                 ), f5bd(0:n+1), q2d(0:n+1), q2bd(0:n+1)
      INTRINSIC DSQRT
      INTRINSIC DABS
      DOUBLE PRECISION x1
      DOUBLE PRECISION x1d
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0d
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1d
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d
      INTEGER ii1
C
C
      gam = 1.4d0
      cmax = 0.0d0
      cmaxd = 0.D0
C
C
C
C
C
C
C
C calculate time step
C
C-----------------------------------------------------------------------
      DO ii=0,n+1
        arg1d = (gam*presd(ii)*u1(ii)-gam*pres(ii)*u1d(ii))/u1(ii)**2
        arg1 = gam*pres(ii)/u1(ii)
        IF (arg1 .EQ. 0.0) THEN
          x1d = 0.D0
        ELSE
          x1d = arg1d/(2.D0*DSQRT(arg1))
        END IF
        x1 = DSQRT(arg1)
        IF (x1 .GE. 0.) THEN
          dabs0d = x1d
          dabs0 = x1
        ELSE
          dabs0d = -x1d
          dabs0 = -x1
        END IF
        IF (u2(ii)/u1(ii) .GE. 0.) THEN
          dabs1d = (u2d(ii)*u1(ii)-u2(ii)*u1d(ii))/u1(ii)**2
          dabs1 = u2(ii)/u1(ii)
        ELSE
          dabs1d = -((u2d(ii)*u1(ii)-u2(ii)*u1d(ii))/u1(ii)**2)
          dabs1 = -(u2(ii)/u1(ii))
        END IF
        cd = dabs0d + dabs1d
        c = dabs0 + dabs1
C      print*, c
        IF (c .GE. cmax) THEN
          cmaxd = cd
          cmax = c
        END IF
      ENDDO
C
      dtd = -(cfl*dx*cmaxd/cmax**2)
      dt = cfl*dx/cmax
Cdt = 0.001
      taud = dtd/dx
      tau = dt/dx
      DO ii1=0,n+1
        f1d(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        f2d(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        f5d(ii1) = 0.D0
      ENDDO
C
C
C
C      print*, dt
C
C
C
C
C
C
C initialise variables:
C       calculate f vector 0-->N+1
C       calculate q vector 0-->N+1
C-----------------------------------------------------------------------
C
      DO ii=0,n+1
        CALL FVECTOR_D(u1(ii), u1d(ii), u2(ii), u2d(ii), u5(ii), u5d(ii)
     +                 , f1(ii), f1d(ii), f2(ii), f2d(ii), f5(ii), f5d(
     +                 ii))
      ENDDO
      DO ii1=0,n+1
        q2d(ii1) = 0.D0
      ENDDO
      DO ii=0,n+1
        CALL QVECTOR_D(u1(ii), u1d(ii), u2(ii), u2d(ii), u5(ii), u5d(ii)
     +                 , q1(ii), q2(ii), q2d(ii), q5(ii), s(ii), sd(ii)
     +                 , sx(ii), sxd(ii))
      ENDDO
      DO ii1=0,n+1
        u1bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        u5bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        u2bd(ii1) = 0.D0
      ENDDO
C
C
C
C calculate predictor terms:
C       calculate u vector predictor terms 0-->N
C       calculate f vector predictor terms 0-->N
C       calculate q vector predictor terms 0-->N
C-----------------------------------------------------------------------
C
      DO ii=0,n
        u1bd(ii) = u1d(ii) - taud*(f1(ii+1)-f1(ii)) - tau*(f1d(ii+1)-f1d
     +    (ii)) + q1(ii)*dtd
        u1b(ii) = u1(ii) - tau*(f1(ii+1)-f1(ii)) + dt*q1(ii)
        u2bd(ii) = u2d(ii) - taud*(f2(ii+1)-f2(ii)) - tau*(f2d(ii+1)-f2d
     +    (ii)) + dtd*q2(ii) + dt*q2d(ii)
        u2b(ii) = u2(ii) - tau*(f2(ii+1)-f2(ii)) + dt*q2(ii)
        u5bd(ii) = u5d(ii) - taud*(f5(ii+1)-f5(ii)) - tau*(f5d(ii+1)-f5d
     +    (ii)) + q5(ii)*dtd
        u5b(ii) = u5(ii) - tau*(f5(ii+1)-f5(ii)) + dt*q5(ii)
      ENDDO
      DO ii1=0,n+1
        f1bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        f5bd(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        f2bd(ii1) = 0.D0
      ENDDO
C
      DO ii=0,n
        CALL FVECTOR_D(u1b(ii), u1bd(ii), u2b(ii), u2bd(ii), u5b(ii), 
     +                 u5bd(ii), f1b(ii), f1bd(ii), f2b(ii), f2bd(ii), 
     +                 f5b(ii), f5bd(ii))
      ENDDO
      DO ii1=0,n+1
        q2bd(ii1) = 0.D0
      ENDDO
C
      DO ii=0,n
        CALL QVECTOR_D(u1b(ii), u1bd(ii), u2b(ii), u2bd(ii), u5b(ii), 
     +                 u5bd(ii), q1b(ii), q2b(ii), q2bd(ii), q5b(ii), s(
     +                 ii), sd(ii), sx(ii), sxd(ii))
      ENDDO
C
C
C
C update:
C       calculate fully updated u vector 1-->N
C-----------------------------------------------------------------------
C
      DO ii=1,n
        u1d(ii) = 0.5*(u1d(ii)+u1bd(ii)) - 0.5*(taud*(f1b(ii)-f1b(ii-1))
     +    +tau*(f1bd(ii)-f1bd(ii-1))) + q1b(ii)*dtd/2
        u1(ii) = 0.5*(u1(ii)+u1b(ii)) - 0.5*tau*(f1b(ii)-f1b(ii-1)) + dt
     +    *q1b(ii)/2
        u2d(ii) = 0.5*(u2d(ii)+u2bd(ii)) - 0.5*(taud*(f2b(ii)-f2b(ii-1))
     +    +tau*(f2bd(ii)-f2bd(ii-1))) + (dtd*q2b(ii)+dt*q2bd(ii))/2
        u2(ii) = 0.5*(u2(ii)+u2b(ii)) - 0.5*tau*(f2b(ii)-f2b(ii-1)) + dt
     +    *q2b(ii)/2
        u5d(ii) = 0.5*(u5d(ii)+u5bd(ii)) - 0.5*(taud*(f5b(ii)-f5b(ii-1))
     +    +tau*(f5bd(ii)-f5bd(ii-1))) + q5b(ii)*dtd/2
        u5(ii) = 0.5*(u5(ii)+u5b(ii)) - 0.5*tau*(f5b(ii)-f5b(ii-1)) + dt
     +    *q5b(ii)/2
        presd(ii) = (gam-1)*(u5d(ii)-(0.5d0*2*u2(ii)*u2d(ii)*u1(ii)-
     +    0.5d0*u2(ii)**2*u1d(ii))/u1(ii)**2)
        pres(ii) = (gam-1)*(u5(ii)-0.5d0*u2(ii)**2/u1(ii))
      ENDDO
      END

C  Differentiation of fvector in forward (tangent) mode:
C   variations   of useful results: f1 f2 f5
C   with respect to varying inputs: u1 u2 u5
C
C
C
C
      SUBROUTINE FVECTOR_D(u1, u1d, u2, u2d, u5, u5d, f1, f1d, f2, f2d, 
     +                     f5, f5d)
      IMPLICIT NONE
C
C
C
      DOUBLE PRECISION, INTENT(IN) :: u1, u2, u5
      DOUBLE PRECISION, INTENT(IN) :: u1d, u2d, u5d
      DOUBLE PRECISION, INTENT(OUT) :: f1, f2, f5
      DOUBLE PRECISION, INTENT(OUT) :: f1d, f2d, f5d
      DOUBLE PRECISION pres, vel, gam
      DOUBLE PRECISION presd, veld
C
C area terms S inlculded in the u variable, or cancelled
      gam = 1.40
C
C
C
C clculate pressure
      presd = (gam-1)*(u5d-(0.5*2*u2*u2d*u1-0.5*u2**2*u1d)/u1**2)
      pres = (gam-1)*(u5-0.5*u2**2/u1)
C
C calculate velocity
      veld = (u2d*u1-u2*u1d)/u1**2
      vel = u2/u1
C
C
C calculate f vector
      f1d = veld*u1 + vel*u1d
      f1 = vel*u1
      f2d = veld*u2 + vel*u2d + presd
      f2 = vel*u2 + pres
      f5d = veld*u5 + vel*u5d + presd*vel + pres*veld
      f5 = vel*u5 + pres*vel
      END

C  Differentiation of qvector in forward (tangent) mode:
C   variations   of useful results: q2
C   with respect to varying inputs: s u1 u2 u5 sx
C
C
C
C
      SUBROUTINE QVECTOR_D(u1, u1d, u2, u2d, u5, u5d, q1, q2, q2d, q5, s
     +                     , sd, sx, sxd)
      IMPLICIT NONE
C
C
C
      DOUBLE PRECISION, INTENT(IN) :: u1, u2, u5, s, sx
      DOUBLE PRECISION, INTENT(IN) :: u1d, u2d, u5d, sd, sxd
      DOUBLE PRECISION, INTENT(OUT) :: q1, q2, q5
      DOUBLE PRECISION, INTENT(OUT) :: q2d
      DOUBLE PRECISION pres, gam
      DOUBLE PRECISION presd
C
      gam = 1.40
C
C
C
C clculate pressure
      presd = ((gam-1)*(u5d-(0.5*2*u2*u2d*u1-0.5*u2**2*u1d)/u1**2)*s-(
     +  gam-1)*(u5-0.5*u2**2/u1)*sd)/s**2
      pres = (gam-1)*(u5-0.5*u2**2/u1)/s
C
C
C calculate q vector
      q1 = 0.0d0
      q2d = presd*sx + pres*sxd
      q2 = pres*sx
      q5 = 0.0d0
      END

C  Differentiation of meshing in forward (tangent) mode:
C   variations   of useful results: s sx
C   with respect to varying inputs: area_rat
C
C
C
C
      SUBROUTINE MESHING_D(area_rat, area_ratd, n, s, sd, sx, sxd, dx, 
     +                     xpos)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER, INTENT(IN) :: n
      DOUBLE PRECISION, INTENT(IN) :: area_rat
      DOUBLE PRECISION, INTENT(IN) :: area_ratd
      DOUBLE PRECISION, INTENT(OUT) :: dx
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: s, sx
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: sd, sxd
      DOUBLE PRECISION, DIMENSION(-1:n+1), INTENT(OUT) :: xpos
C
      INTEGER ii
      DOUBLE PRECISION l, x, r, pi
      DOUBLE PRECISION rd
      INTRINSIC COS
      INTRINSIC SIN
      DOUBLE PRECISION arg1
      INTEGER ii1
C
C
C
C
C
C
C
      l = 1.0
      rd = area_ratd
      r = area_rat
      pi = 3.1415
      dx = l/n
      DO ii1=0,n+1
        sd(ii1) = 0.D0
      ENDDO
      DO ii1=0,n+1
        sxd(ii1) = 0.D0
      ENDDO
C
C
      DO ii=1,n
C
        xpos(ii) = ii*l/n
        x = (ii-0.5)*l/n
C
        arg1 = 2*pi*x/l
        sd(ii) = (rd*2*r-(r+1)*2*rd)*(1+(r-1)/(r+1)*COS(arg1))/(2**2*r**
     +    2) + COS(arg1)*(rd*(r+1)-(r-1)*rd)/((r+1)*2*r)
        s(ii) = (r+1)/(2*r)*(1+(r-1)/(r+1)*COS(arg1))
        arg1 = 2*pi*x/l
        sxd(ii) = pi*SIN(arg1)*(-(rd*r*l)-(1-r)*l*rd)/(r**2*l**2)
        sx(ii) = pi*((1-r)/(r*l))*SIN(arg1)
      ENDDO
C
C
      sd(0) = sd(1)
      s(0) = s(1)
      sd(n+1) = sd(n)
      s(n+1) = s(n)
C
      sxd(0) = sxd(1)
      sx(0) = sx(1)
      sxd(n+1) = sxd(n)
      sx(n+1) = sx(n)
C
C
      xpos(-1) = -(l/n)
      xpos(0) = 0
      xpos(n+1) = 1 + l/n
      END

C  Differentiation of boundaries in forward (tangent) mode:
C   variations   of useful results: u1 u2 u5 pres
C   with respect to varying inputs: u1 u2 u5 pres
C
C
C
C
      SUBROUTINE BOUNDARIES_D(n, mach_inf, pres_rat, pres, presd, u1, 
     +                        u1d, u2, u2d, u5, u5d)
      IMPLICIT NONE
C
C
C
C
      INTEGER, INTENT(IN) :: n
      DOUBLE PRECISION, INTENT(IN) :: mach_inf, pres_rat
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: pres, u1, u2, 
     +                                                   u5
      DOUBLE PRECISION, DIMENSION(0:n+1), INTENT(OUT) :: presd, u1d, u2d
     +                                                   , u5d
C
      INTEGER ii
      DOUBLE PRECISION gam, pinf, pstag, rinf, rstag, ubc, mbc, pbc, rbc
      DOUBLE PRECISION ubcd, mbcd, pbcd, rbcd
      DOUBLE PRECISION pwx1
      DOUBLE PRECISION pwx1d
      DOUBLE PRECISION pwy1
      DOUBLE PRECISION pwr1
      DOUBLE PRECISION pwr1d
C
C
C useful values near the inflow
      gam = 1.4
      pinf = 1.0/gam
      pwx1 = 1 + 0.5*(gam-1)*mach_inf**2
      pwy1 = gam/(gam-1)
      pwr1 = pwx1**pwy1
      pstag = pinf*pwr1
      rinf = 1.0
      pwx1 = 1 + 0.5*(gam-1)*mach_inf**2
      pwy1 = 1.0/(gam-1)
      pwr1 = pwx1**pwy1
      rstag = rinf*pwr1
C
      ubcd = (u2d(1)*u1(1)-u2(1)*u1d(1))/u1(1)**2
      ubc = u2(1)/u1(1)
      mbcd = ((ubcd*ubc+ubc*ubcd)*(1+0.5*(gam-1)*mach_inf**2-0.5*(gam-1)
     +  *ubc**2)+ubc**3*0.5*(gam-1)*2*ubcd)/(1+0.5*(gam-1)*mach_inf**2-
     +  0.5*(gam-1)*ubc**2)**2
      mbc = ubc*ubc/(1+0.5*(gam-1)*mach_inf**2-0.5*(gam-1)*ubc**2)
      pwx1d = 0.5*(gam-1)*2*mbc*mbcd
      pwx1 = 1 + 0.5*(gam-1)*mbc**2
      pwy1 = gam/(gam-1)
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))) 
     +THEN
        pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d
      ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
        pwr1d = pwx1d
      ELSE
        pwr1d = 0.0
      END IF
      pwr1 = pwx1**pwy1
      pbcd = -(pstag*pwr1d/pwr1**2)
      pbc = pstag/pwr1
      pwx1d = 0.5*(gam-1)*2*mbc*mbcd
      pwx1 = 1 + 0.5*(gam-1)*mbc**2
      pwy1 = 1.0/(gam-1)
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))) 
     +THEN
        pwr1d = pwy1*pwx1**(pwy1-1)*pwx1d
      ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
        pwr1d = pwx1d
      ELSE
        pwr1d = 0.0
      END IF
      pwr1 = pwx1**pwy1
      rbcd = -(rstag*pwr1d/pwr1**2)
      rbc = rstag/pwr1
C
C halo cells at the inflow
      presd(0) = pbcd
      pres(0) = pbc
      u1d(0) = rbcd
      u1(0) = rbc
      u2d(0) = rbcd*ubc + rbc*ubcd
      u2(0) = rbc*ubc
      u5d(0) = pbcd/(gam-1) + 0.5*(rbcd*ubc**2+rbc*2*ubc*ubcd)
      u5(0) = pbc/(gam-1) + 0.5*rbc*ubc**2
C
C halo cells at the outflow
      presd(n+1) = 0.D0
      pres(n+1) = pinf*pres_rat
      u1d(n+1) = u1d(n)
      u1(n+1) = u1(n)
      u2d(n+1) = u2d(n)
      u2(n+1) = u2(n)
      u5d(n+1) = presd(n+1)/(gam-1) + (0.5*2*u2(n+1)*u2d(n+1)*u1(n+1)-
     +  0.5*u2(n+1)**2*u1d(n+1))/u1(n+1)**2
      u5(n+1) = pres(n+1)/(gam-1) + 0.5*u2(n+1)**2/u1(n+1)
      END


