C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7260) - 18 Jan 2019 10:11
C
C  Differentiation of cost in forward (tangent) mode:
C   variations   of useful results: j
C   with respect to varying inputs: ue um ur arearat
C   RW status of diff variables: j:out ue:in um:in ur:in arearat:in
      SUBROUTINE COST_D(j, jd, arearat, arearatd, ur, urd, um, umd, ue, 
     +                  ued, ni)
      IMPLICIT NONE
C
C
C
C
      INTEGER, INTENT(IN) :: ni
      DOUBLE PRECISION, INTENT(IN) :: arearat
      DOUBLE PRECISION, INTENT(IN) :: arearatd
      DOUBLE PRECISION, INTENT(OUT) :: j
      DOUBLE PRECISION, INTENT(OUT) :: jd
      DOUBLE PRECISION, DIMENSION(-1:ni+1), INTENT(IN) :: ur, um, ue
      DOUBLE PRECISION, DIMENSION(-1:ni+1), INTENT(IN) :: urd, umd, ued
C
      INTEGER ii
      DOUBLE PRECISION, DIMENSION(-1:ni+2) :: x, ds, dx, area, dadx
      DOUBLE PRECISION dadxd(-1:ni+2)
      DOUBLE PRECISION, DIMENSION(-1:ni+1) :: pres
      DOUBLE PRECISION presd(-1:ni+1)
      INTRINSIC DSQRT
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d
      DOUBLE PRECISION result1
      DOUBLE PRECISION result1d
      INTEGER ii1
C
C
C create mesh
C useful inputs: ni, arearat        useful outputs: dx
      j = 0.0d0
C
C
C
C
C
C for the cost function, integrate normal pressure 
C on both upper and lower nozzle surfaces
C-----------------------------------------------------------------------
C
C
      CALL GRIDDATA_D(ni, x, ds, dx, area, dadx, dadxd, arearat, 
     +                arearatd)
      jd = 0.D0
      DO ii1=-1,ni+1
        presd(ii1) = 0.D0
      ENDDO
C
C calculate pressure
      DO ii=1,ni
C
C integrate pressure
        presd(ii) = (1.4d0-1.0d0)*(ued(ii)-(0.5d0*(umd(ii)*um(ii)+um(ii)
     +    *umd(ii))*ur(ii)-0.5d0*um(ii)**2*urd(ii))/ur(ii)**2)
        pres(ii) = (1.4d0-1.0d0)*(ue(ii)-0.5d0*um(ii)*um(ii)/ur(ii))
C
        arg1d = dadxd(ii)*dadx(ii) + dadx(ii)*dadxd(ii)
        arg1 = 1 + dadx(ii)*dadx(ii)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.D0
        ELSE
          result1d = arg1d/(2.D0*DSQRT(arg1))
        END IF
        result1 = DSQRT(arg1)
        jd = jd + 2.0d0*dx(ii)*(presd(ii)*result1+pres(ii)*result1d)
        j = j + 2.0d0*pres(ii)*dx(ii)*result1
      ENDDO
      END

C  Differentiation of griddata in forward (tangent) mode:
C   variations   of useful results: dadx
C   with respect to varying inputs: arearat
C***********************************************************************
C  CHRISTIAN ALLEN. UNIVERSITY OF BRISTOL.
C  LAST UPDATE: NOVEMBER 2014.
C***********************************************************************
C
      SUBROUTINE GRIDDATA_D(ni, x, ds, dx, area, dadx, dadxd, arearat, 
     +                      arearatd)
      IMPLICIT NONE
C
      INTEGER ni
      DOUBLE PRECISION, DIMENSION(-1:ni+2) :: x, ds, dx, area, dadx, xc
      DOUBLE PRECISION dadxd(-1:ni+2)
C      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:):: xc
      DOUBLE PRECISION arearat, pi
      DOUBLE PRECISION arearatd
      INTEGER i
      INTRINSIC DFLOAT
      INTRINSIC DATAN
      INTRINSIC DCOS
      INTRINSIC DSIN
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg2
      INTEGER ii1
C
C  CALCULATE CELL LENGTHS AND DISTANCES BETWEEN CELL CENTRES
C
C      ALLOCATE(xc(-1:ni+2))
C
      DO i=0,ni
        x(i) = DFLOAT(i)*1.0d0/DFLOAT(ni)
      ENDDO
C
      DO i=1,ni
        xc(i) = 0.5d0*(x(i)+x(i-1))
      ENDDO
      xc(0) = 2.0d0*x(0) - xc(1)
      xc(ni+1) = 2.0d0*x(ni) - xc(ni)
      x(-1) = 2.0d0*x(0) - x(1)
      x(ni+1) = 2.0d0*x(ni) - x(ni-1)
      DO i=1,ni+1
        ds(i) = xc(i) - xc(i-1)
      ENDDO
      ds(0) = ds(1)
      ds(ni+2) = ds(ni+1)
      DO i=0,ni+1
        dx(i) = x(i) - x(i-1)
      ENDDO
C
      pi = 4.0d0*DATAN(1.0d0)
      DO ii1=-1,ni+2
        dadxd(ii1) = 0.D0
      ENDDO
C
      DO i=0,ni
        IF (x(i) .LT. 0.1d0) THEN
          area(i) = arearat
          dadxd(i) = 0.D0
          dadx(i) = 0.0d0
        ELSE IF (x(i) .GT. 0.9d0) THEN
          area(i) = arearat
          dadxd(i) = 0.D0
          dadx(i) = 0.0d0
        ELSE
          arg1 = 1.25d0*pi*(x(i)-0.1d0)
          area(i) = 1.0d0 + (arearat-1.0d0)*DCOS(arg1)**2
          arg1 = 1.25d0*pi*(x(i)-0.1d0)
          arg2 = 1.25d0*pi*(x(i)-0.1d0)
          dadxd(i) = -(2.5d0*pi*DCOS(arg1)*DSIN(arg2)*arearatd)
          dadx(i) = -(2.5d0*pi*(arearat-1.0d0)*DCOS(arg1)*DSIN(arg2))
        END IF
      ENDDO
C
C      DEALLOCATE(xc)
C
      RETURN
      END
C
C**********************************************************************


